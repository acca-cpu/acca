pushs[.s] a:reg | null               => [1101110000000000000000000ssaaaaa];
pushp[.s] a:reg | null, b:reg | null => [11011000000000000000ssaaaaabbbbb];
pops[.s]  a:reg | null               => [1101010000000000000000000ssaaaaa];
popp[.s]  a:reg | null, b:reg | null => [1101000000000000000000ssaaaabbbb];

lds[.s] d:reg, a:reg        => [1100110000000000000000ssddddaaaa];
ldp[.s] d:reg, e:reg, a:reg => [110010000000000000ssddddeeeeaaaa];
sts[.s] a:reg, b:reg        => [1100010000000000000000ssaaaabbbb];
stp[.s] a:reg, b:reg, c:reg => [110000000000000000ssaaaabbbbcccc];

ldi d:reg, a:imm16, [b:imm6], [c:imm2] => [1110ccaaaaaaaaaaaaaaaabbbbbbdddd];

ldr d:reg, a:rel22(next_byte_relative_immediate) => [001100ddddaaaaaaaaaaaaaaaaaaaaaa];

copy[.s] d:reg, S:reg => [1010100000000000000000ssddddSSSS];

add_reg = add[.s] d:reg | null, a:reg, b:reg,                        [c:bool], [f:bool] => [101001000000000sscfdddddaaaabbbb];
add_imm = add[.s] d:reg | null, a:reg, b:imm11, [S:imm3], [A: bool], [c:bool], [f:bool] => [1011sscfdddddaaaaASSSbbbbbbbbbbb];
sub_reg = sub[.s] d:reg | null, a:reg, b:reg,                        [B:bool], [f:bool] => [101000000000000ssBfdddddaaaabbbb];
sub_imm = sub[.s] d:reg | null, a:reg, b:imm11, [S:imm3], [A: bool], [B:bool], [f:bool] => [1001ssBfdddddaaaaASSSbbbbbbbbbbb];

mul d:reg, a:reg, b:reg, [S:bool], [f:bool] => {
	d: reg, a: reg, b: reg, S: bool, f: bool {
		let s = size_of(a, b);
		let t = size_of(d);
	} => [10001100000000ssttSfddddaaaabbbb],
};

div[.s] d:reg, r:reg, a:reg, b:reg, [S:bool], [f:bool] => [100010000000ssSfddddrrrraaaabbbb];

and_reg = and[.s] d:reg | null, a:reg, b:reg,              [f:bool] => [1000010000000000ssfdddddaaaabbbb];
and_imm = and[.s] d:reg | null, a:reg, b:imm11, [S: imm3], [f:bool] => [100000ssfdddddaaaabbbbbbbbbbbSSS];
or_reg  = or[.s]  d:reg | null, a:reg, b:reg,              [f:bool] => [0111110000000000ssfdddddaaaabbbb];
or_imm  = or[.s]  d:reg | null, a:reg, b:imm11, [S: imm3], [f:bool] => [011110ssfdddddaaaabbbbbbbbbbbSSS];
xor_reg = xor[.s] d:reg | null, a:reg, b:reg,              [f:bool] => [0111010000000000ssfdddddaaaabbbb];
xor_imm = xor[.s] d:reg | null, a:reg, b:imm11, [S: imm3], [f:bool] => [011100ssfdddddaaaabbbbbbbbbbbSSS];

shl[.s] d:reg | null, a:reg, b:reg | imm7, [f: bool] => {
	d: reg | null, a: reg, b: reg,  f: bool => [0110100000000000ssfdddddaaaabbbb],
	d: reg | null, a: reg, b: imm7, f: bool => [0110110000000ssfdddddaaaabbbbbbb],
};
shr[.s] d:reg | null, a:reg, b:reg | imm7, [A:bool], [f:bool] => {
	d: reg | null, a: reg, b: reg,  A: bool, f: bool => [011000000000000ssAfdddddaaaabbbb],
	d: reg | null, a: reg, b: imm7, A: bool, f: bool => [011001000000ssAfdddddaaaabbbbbbb],
};
rot[.s] d:reg | null, a:reg, b:reg | imm7, [f: bool] => {
	d: reg | null, a: reg, b: reg,  f: bool => [0101100000000000ssfdddddaaaabbbb],
	d: reg | null, a: reg, b: imm7, f: bool => [0101110000000ssfdddddaaaabbbbbbb],
};

neg[.s]   d:reg, a:reg, [f: bool] => [010101000000000000000ssfddddaaaa];
bswap[.s] d:reg, a:reg, [f: bool] => [010100000000000000000ssfddddaaaa];

jmpa[.c] a:reg => [010011000000000000000000ccccaaaa];
jmpr[.c] a:reg | rel22 => {
	a: reg   => [010010000000000000000000ccccaaaa],
	a: rel22 => [010001ccccaaaaaaaaaaaaaaaaaaaaaa],
};

cjmpa.c[.s] a:reg, b:reg, C:reg => [001111000000000cccssaaaabbbbCCCC];
cjmpr.c[.s] a:reg | rel13, b:reg, C:reg => {
	a: reg,   b: reg, C: reg => [001101000000000cccssaaaabbbbCCCC],
	a: rel13, b: reg, C: reg => [001011cccssbbbbCCCCaaaaaaaaaaaaa],
};

calla[.c] a:reg => [001010000000000000000000ccccaaaa];
callr[.c] a:reg | rel22 => {
	a: reg   => [001001000000000000000000ccccaaaa],
	a: rel22 => [001000ccccaaaaaaaaaaaaaaaaaaaaaa],
};

ret         => [00011100000000000000000000000000];
eret        => [00011000000000000000000000000000];
udf         => [00000000000000000000000000000000];
dbg         => [00001000000000000000000000000000];
exc a:imm16 => [0000110000000000aaaaaaaaaaaaaaaa];
nop         => [00000100000000000000000000000000];

ldm d:reg, a:imm22(next_machine_register_or_immediate) => [000100ddddaaaaaaaaaaaaaaaaaaaaaa];
stm d:imm22(next_machine_register_or_immediate), a:reg => [000101aaaadddddddddddddddddddddd];
